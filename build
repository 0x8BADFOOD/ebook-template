#!/usr/bin/env python
#
# Build script. Uses doit: http://pydoit.org/

import sys
from shutil import *
import os
from glob import glob
from string import Template

sys.path.insert(0, os.path.dirname(__file__))
from lib import *

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

BOOK_SRC_DIR = 'book'
TMP_DIR  = 'tmp'
FILES_DIR = 'files'

BUILD_FILE = 'build'

# Generated files

OUTPUT_BASENAME    = 'book'

EPUB_METADATA      = f'{TMP_DIR}/epub-metadata.xml'
LATEX_COVER_PAGE   = f'{TMP_DIR}/latex-title.latex'

OUTPUT_HTML        = f'{OUTPUT_BASENAME}.html'
OUTPUT_PDF         = f'{OUTPUT_BASENAME}.pdf'
OUTPUT_EPUB        = f'{OUTPUT_BASENAME}.epub'
OUTPUT_DOCX        = f'{OUTPUT_BASENAME}.docx'
OUTPUT_LATEX       = f'{OUTPUT_BASENAME}.latex'
OUTPUT_JSON        = f'{OUTPUT_BASENAME}.json'

COMBINED_METADATA  = f'{TMP_DIR}/metadata.yaml'

# Input files

EPUB_METADATA_TEMPLATE = f'{FILES_DIR}/epub-metadata.xml'

REFERENCES_YAML    = f'{BOOK_SRC_DIR}/references.yaml'
REFERENCES         = f'{FILES_DIR}/references.md'
METADATA_YAML      = f'{BOOK_SRC_DIR}/metadata.yaml'

metadata           = load_metadata(METADATA_YAML)
uses_references    = os.path.exists(REFERENCES_YAML)

COVER_IMAGE        = f'{BOOK_SRC_DIR}/cover.png'
CHAPTERS           = glob(f'{BOOK_SRC_DIR}/chapter-*.md')
COPYRIGHT          = f'{BOOK_SRC_DIR}/copyright.md'
LATEX_HEADER       = f'{FILES_DIR}/header.latex'

BOOK_FILE_LIST    = (
    [COMBINED_METADATA, COPYRIGHT] +
    maybe_file(f'{BOOK_SRC_DIR}/dedication.md') +
    maybe_file(f'{BOOK_SRC_DIR}/prologue.md') +
    CHAPTERS +
    maybe_file(f'{BOOK_SRC_DIR}/epilogue.md') +
    maybe_file(f'{BOOK_SRC_DIR}/acknowledgments.md') +
    ([REFERENCES] if uses_references else [])
)

HTML_CSS           = f'{FILES_DIR}/html.css'
EPUB_CSS           = f'{FILES_DIR}/epub.css'
LATEX_TEMPLATE     = f'{FILES_DIR}/latex.template'
REF_DOCX           = f'{FILES_DIR}/custom-reference.docx'
PANDOC_FILTER      = 'scripts/pandoc-filter.py'

# Lists of dependencies, for ease of reference.
DEPS       = BOOK_FILE_LIST + [BUILD_FILE, PANDOC_FILTER, COMBINED_METADATA]
EPUB_DEPS  = DEPS + [EPUB_METADATA, COVER_IMAGE, EPUB_CSS]
HTML_DEPS  = DEPS + [HTML_CSS]
LATEX_DEPS = DEPS + [COVER_IMAGE, LATEX_COVER_PAGE, LATEX_TEMPLATE, LATEX_HEADER]
DOCX_DEPS  = DEPS + [REF_DOCX]

# +RTS and -RTS delimit Haskell runtime options. See
# http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html
#
# -Ksize sets the stack size. -K10m uses a 10 Mb stack, for instance. The
# default size is 8M.

HASKELL_OPTS = '+RTS -K20m -RTS'
#HASKELL_OPTS = ''
INPUT_FORMAT = "markdown+line_blocks+escaped_line_breaks"
COMMON_PANDOC_OPTS = (
    f"-F {PANDOC_FILTER} -s -f {INPUT_FORMAT} --smart {HASKELL_OPTS} " +
    "-F pandoc-citeproc " if uses_references else ""
)
NON_LATEX_PANDOC_OPTS = f"{COMMON_PANDOC_OPTS} --top-level-division=chapter"
LATEX_PANDOC_OPTS = (f"{COMMON_PANDOC_OPTS} --template={LATEX_TEMPLATE} " +
                     f"-t latex -H {LATEX_HEADER} {LATEX_COVER_PAGE}")

# ---------------------------------------------------------------------------
# Tasks
# ---------------------------------------------------------------------------

DOIT_DB = 'doit-db.json'

DOIT_CONFIG = {
    'default_tasks': ['html', 'pdf', 'docx', 'epub'],
    'backend': 'json',
    'dep_file': DOIT_DB
}

def _latex(target):
    with preprocess_markdown(*BOOK_FILE_LIST) as md:
        sh(f"pandoc {LATEX_PANDOC_OPTS} -o {target} {md}")

def task_clobber():
    '''
    Convenient way to run: ./build clean -a
    '''
    def run(targets):
        sh('./build clean -a')
        rm_f(glob('*.bak'))
        rm_rf('__pycache__')
        rm_rf('lib/__pycache__')
        rm_rf(f'{BOOK_SRC_DIR}__pycache__')
        rm_rf('tmp')

    return {
        'actions': [run]
    }

def task_html():
    '''
    Generate HTML output.
    '''
    def run(targets):
        with preprocess_markdown(*BOOK_FILE_LIST) as md:
            sh(f"pandoc {NON_LATEX_PANDOC_OPTS} -o {targets[0]} -t html " +
               f"--self-contained --css={HTML_CSS} {md}")

    return {
        'actions': [run],
        'file_dep': HTML_DEPS,
        'targets': [OUTPUT_HTML],
        'clean':   True
    }


def task_pdf():
    '''
    Generate PDF output.
    '''
    return {
        'actions': [(_latex, [OUTPUT_PDF])],
        'file_dep': LATEX_DEPS,
        'targets': [OUTPUT_PDF],
        'clean':   True
    }

def task_latex():
    '''
    Generate LaTeX output (for debugging).
    '''
    return {
        'actions': [(_latex, [OUTPUT_LATEX])],
        'file_dep': LATEX_DEPS,
        'targets': [OUTPUT_LATEX],
        'clean':   True
    }

def task_json():
    '''
    Generate Pandoc AST JSON, pretty-printed (for debugging).
    '''
    def run(targets):
        with preprocess_markdown(*BOOK_FILE_LIST) as md:
            temp = '_ast.json'
            try:
                sh(f'pandoc {NON_LATEX_PANDOC_OPTS} -o _ast.json -t json {md}')
                with open(temp, 'r') as f:
                    import json
                    js = json.load(f)
                    with open(targets[0], 'w') as out:
                        out.write(json.dumps(js, sort_keys=False, indent=2))
            finally:
                rm_f(temp, silent=True)


    return {
        'actions':  [run],
        'file_dep': HTML_DEPS,
        'targets':  [OUTPUT_JSON],
        'clean':    True
    }

def task_docx():
    '''
    Generate MS Word output.
    '''
    def run(targets):
        with preprocess_markdown(*BOOK_FILE_LIST) as md:
            sh(f"pandoc {NON_LATEX_PANDOC_OPTS} -o {targets[0]} -t docx " +
               f"--reference-docx={REF_DOCX} {md}")

    return {
        'actions': [run],
        'file_dep': DOCX_DEPS,
        'targets': [OUTPUT_DOCX],
        'clean':   True
    }

def task_epub():
    '''
    Generate ePub output.
    '''
    def run(targets):
        with preprocess_markdown(*BOOK_FILE_LIST) as md:
            sh(f"pandoc {NON_LATEX_PANDOC_OPTS} -o {targets[0]} -t epub " +
               f"--epub-stylesheet={EPUB_CSS} "
               f"--epub-metadata={EPUB_METADATA} "
               f"--epub-cover-image={COVER_IMAGE} {md}")

    return {
        'actions': [run],
        'file_dep': EPUB_DEPS,
        'targets': [OUTPUT_EPUB],
        'clean':   True
    }

def task_latex_title():
    '''
    Generate LaTeX title file.
    '''
    # Note: The following requires a custom LaTeX template with
    # \usepackage{graphicx} in the preamble.
    def run(targets):
        with target_dir_for(LATEX_COVER_PAGE):
            with open(LATEX_COVER_PAGE, 'w') as out:
                out.write(r'\begin{titlepage}' + "\n")
                out.write(r'\includegraphics{' + COVER_IMAGE + "}\n")
                out.write(r'\end{titlepage}' + "\n")

    return {
        'actions':  [run],
        'file_dep': [BUILD_FILE],
        'targets':  [LATEX_COVER_PAGE],
        'clean':    True
    }

def task_combined_metadata():
    '''
    Generate the consolidated metadata file.
    '''
    def run(targets):
        with open(targets[0], 'w') as out:
            for f in (METADATA_YAML, REFERENCES_YAML):
                out.write('---\n')
                if not os.path.exists(f):
                    continue
                with open(f, 'r') as y:
                    out.write(f'###\n### {f}\n###\n')
                    for line in y.readlines():
                        if line.startswith('---'):
                            continue
                        out.write(line)
                out.write('---\n')

    return {
        'actions':  [run],
        'file_dep': [BUILD_FILE, METADATA_YAML, REFERENCES_YAML],
        'targets':  [COMBINED_METADATA],
        'clean':    True
    }
        
def task_epub_metadata():
    '''
    Generate the ePub metadata file.
    '''
    def run(targets):
        with open(targets[0], 'w') as out:
            with open(EPUB_METADATA_TEMPLATE, 'r') as input:
                template = ''.join(input.readlines())

            msg(template)
            identifier = metadata.get('identifier', {}).get('text', '')
            scheme = metadata.get('identifier', {}).get('scheme', '')
            copyright = metadata['copyright']
            data = {
                'identifier':        identifier,
                'identifier_scheme': scheme,
                'copyright_owner':   copyright['owner'],
                'copyright_year':    copyright['year'],
                'publisher':         metadata['publisher'],
                'language':          metadata.get('language', 'en-US'),
                'genre':             metadata.get('genre', '')
            }
            out.write(Template(template).substitute(data))

    return {
        'actions':  [run],
        'file_dep': [EPUB_METADATA_TEMPLATE, BUILD_FILE],
        'targets':  [EPUB_METADATA],
        'clean':    True
    }

def task_combined():
    '''
    Generated one big combined Markdown file (for debugging).
    '''
    def run(targets):
        out = targets[0]
        msg(f"Generating {out}.")
        with target_dir_for(out):
            with preprocess_markdown(*BOOK_FILE_LIST) as md:
                copyfile(md, out)

    return {
        'actions':  [run],
        'file_dep': DEPS,
        'targets':  [f'{TMP_DIR}/temp.md'],
        'clean':    True
    }

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

if __name__ == '__main__':
    import doit
    doit.run(globals())
